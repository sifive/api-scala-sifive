
# Important directories
def buildRoot = mkdir "build"
def root = mkdir "{buildRoot.getPathName}/api-scala-sifive"
def scalaInstall = "scala"
# Where I expect Scala Ivy dependencies to be downloaded
def ivyCache = "ivycache"
def resources = "python/python/3.7.1", "openjdk/java/1.8.0", Nil
# Where mill should keep its metadata
def millHome = "{scalaInstall}/mill_home"

global def readIvyDepsJSON dir =
  source "{dir}/ivydependencies.json" | parseJSONFile


def runDepFetchScript script =
  def bin = source script
  def dir = mkdir scalaInstall
  def deps = sources here `.*\.py`
  makePlan (bin.getPathName, dir.getPathName, Nil) (bin, dir, deps)
  | setPlanResources resources
  | editPlanEnvironment ("PYTHONDONTWRITEBYTECODE=1", _)
  | runJob
  | getJobOutput

def fetchCoursier Unit = runDepFetchScript "{here}/fetch_coursier"
# Unlike Coursier, Wit <= 0.12 didn't fetch Mill so no backwards compatibility concerns
def millBin = runDepFetchScript "{here}/fetch_mill"

def myMakeStatePath x =
  makePlan ("<makeStatePath>", x, Nil) Nil
  | setPlanKeep      False
  | setPlanEcho      Verbose
  | setPlanFnOutputs (\_ x, Nil)
  | runJobWith       virtualRunner
  | getJobOutput

# Maintain compatibility with Wit 0.12 and below
# Wit versions <= 0.12 have a Scala plugin that fetches Coursier, Bloop, and
# all dependencies specified in ivydependencies.json files at the root of wit
# packages (where the wit-manifest.json) resides.
# To maintain backwards compatibility, accept that these dependencies may have
# already been fetched, use virtual jobs to own the files if they already exist
# rather than fetching them ourselves.
def coursierBin =
  match (files scalaInstall `.*coursier.*`)
    bin, Nil = myMakeStatePath bin
    Nil      = fetchCoursier Unit
    l        = makeBadPath (makeError "Multiple coursier executables found! {catWith ", " l}")

# Get ivydependencies.json files 0 or 1 levels under workspace root, or that
# are explicitly published.
# 0/1 levels emulates Wit <= 0.12 behavior where packages are placed directly below
# the workspace root where Wit fetches dependencies in ivydependencies.json
# located at the root of packages.
global topic ivyDepLocations: String
def ivyDepsFiles =
  def addSuffix suffix str = "{str}{suffix}"
  def published = subscribe ivyDepLocations | map (addSuffix "/ivydependencies.json") | map source
  def traversed = sources "." `[^/]*/?ivydependencies\.json`
  def pathCmp a b = scmp a.getPathName b.getPathName
  traversed ++ published | distinctBy pathCmp

# Job that fetches ivy dependencies
def ivyCacheDeps =
  def bin = source "{here}/fetch_ivy_dependencies"
  def dir = mkdir scalaInstall
  def cache = mkdir ivyCache
  def otherDeps = sources here `.*\.py`
  def cmd =
    "python3", bin.getPathName, "--scala-dir", dir.getPathName, "--cache-dir",
    cache.getPathName, map getPathName ivyDepsFiles
  def allDeps = bin, dir, cache, coursierBin, otherDeps ++ ivyDepsFiles
  def listIvycache Unit = files ivyCache `.*`
  match ivyDepsFiles
    Nil = Nil
    _   =
      makePlan cmd allDeps
      | setPlanResources resources
      | editPlanEnvironment ("PYTHONDONTWRITEBYTECODE=1", _)
      | setPlanLocalOnly True
      # Own all files in ivycache, even if they were prefetched by Wit
      | setPlanFnOutputs (\_ listIvycache Unit)
      | runJob
      | getJobOutputs


# Memoized tree for converting from Strings to Paths to jars in Coursier cache
target ivyCacheJars Unit =
  def isJar = matches `.*\.jar` _.getPathName
  ivyCacheDeps
  | filter isJar
  | mapPartial (\p p.getPathName.stripIvyPathPrefix | omap (Pair _ p))
  | listToTree cmpIvyCachePair

# TODO This is kind of sketchy, are releases and maven2 sufficient?
def stripIvyPathPrefix name =
  extract `.*?/(?:releases|maven2)/(.*)` name | head

def ivyDepToCoursierCache (IvyDep org name rev) =
  def prefix = replace `\.` '/' org
  "{prefix}/{name}/{rev}/{name}-{rev}.jar"

def cmpIvyCachePair (Pair n1 _) (Pair n2 _) = n1 <=>* n2

def getIvyDepJars filenames =
  def dummyPath = root # A explicitly dummy path
  def pairs = map (Pair _ dummyPath) filenames
  def mtree = listToTree cmpIvyCachePair pairs
  (ivyCacheJars Unit) ∩ mtree | treeToList | map getPairSecond

# Get the Jar for an IvyDep
# Returns a Path
global def getIvyDepJar dep =
  def err Unit =
    makeBadPath (makeError "{dep.ivyDepToString} not found in downloaded ivy dependencies!")
  def ivyDeps = getIvyDepJars (dep.ivyDepToCoursierCache, Nil)
  match ivyDeps
    value, Nil = value
    Nil        = err Unit
    l          = panic "Found multiple jars for {dep.ivyDepToString}: {format l}"

# TODO
# - Can we make this a fuse job? For some reason coursier can't find visible inputs
# Determines transitive ivy dependencies
# Given List IvyDep, returns List Path
# Returns paths to dep jars and transitive dependencies
global def resolveIvyDeps deps =
  def depStrs = map ivyDepToString deps
  def cachedDeps = ivyCacheDeps
  def job =
    def cmd = coursierBin.getPathName, "fetch", "-q", "--cache", ivyCache, "-m", "offline", depStrs
    makePlan cmd (coursierBin, cachedDeps)
    | setPlanLocalOnly True
    | runJob
  def strs =
    job
    | getJobStdout
    | rmap (tokenize `\n` _ | filter (_ !=* ""))
  # Using the output of coursier, we get the actual paths and filter into requested and transitive
  def stripPrefix str = stripIvyPathPrefix str | getOrFail (makeError "Could not strip ivy path prefix of '{str}'!")
  def filenames = strs | rmapPass (findFailFn stripPrefix _)
  def err paths names =
    def fns = catWith ", " names
    def ps = paths | map format | catWith ", "
    makeBadPath (makeError "Something went wrong! Looking for {fns}, got wrong number of paths: {ps}"), Nil
  match filenames
    Fail err = makeBadPath err, Nil
    Pass fns =
      def jars = getIvyDepJars fns
      if jars.len != fns.len then err jars fns else jars


# TODO improve
global def runIvyDep dep = resolveIvyDeps (dep, Nil) | runJava

# TODO improve
# - Customize java installation
# - Add Java options (eg. -Xmx4G)
# visible excludes classpath
global def runJava classpath main args visible =
  def cp = map getPathName classpath | catWith ":"
  def cmd = "java", "-cp", cp, main, args
  makePlan cmd (visible ++ classpath)
  | setPlanResources ("openjdk/java/1.8.0", Nil)
  | runJob

# TODO Dotty support?
tuple ScalaVersion =
  global Major: Integer
  global Minor: Integer

global def makeScalaVersion major minor =
  ScalaVersion major minor

global def scalaVersionToString (ScalaVersion major minor) =
  "2.{str major}.{str minor}"

global def scalaVersionMajorString (ScalaVersion major _) =
  "2.{str major}"


global def stringToScalaVersion str =
  match (tokenize `\.` str)
    "2", major, minor, Nil = match (int major) (int minor)
      (Some maj) (Some min) = Some (ScalaVersion maj min)
      _ _                   = None
    _ = None

global def stringToScalaVersionResult str =
  match (stringToScalaVersion str)
    Some ver = Pass ver
    None     = Fail (makeError "Invalid ScalaVersion string {str}")

global data ScalaCrossVersion =
  Constant
  Major
  Minor

# TODO additional resolvers/repositories
tuple IvyDep =
  global Org:          String
  global Name:         String
  global Rev:          String

tuple UnexpandedIvyDep =
  global Org:          String
  global Name:         String
  global Rev:          String
  global CrossVersion: ScalaCrossVersion

# rename stringToIvyDep
global def stringToIvyDep string =
  match (tokenize `:` string)
    org, name, rev, Nil         = Some (UnexpandedIvyDep org name rev Constant)
    org, "", name, rev, Nil     = Some (UnexpandedIvyDep org name rev Major)
    org, "", "", name, rev, Nil = Some (UnexpandedIvyDep org name rev Minor)
    _                           = None

def ivyDepToString (IvyDep org name rev) = "{org}:{name}:{rev}"

def unexpandedIvyDepToString (UnexpandedIvyDep org name rev cross) = match cross
  Constant = "{org}:{name}:{rev}"
  Major    = "{org}::{name}:{rev}"
  Minor    = "{org}:::{name}:{rev}"

global def expandIvyDep version (UnexpandedIvyDep org name rev cross) = match cross
  Constant = IvyDep org name rev
  Major    = IvyDep org "{name}_{scalaVersionMajorString version}" rev
  Minor    = IvyDep org "{name}_{scalaVersionToString version}" rev

global def expandJavaIvyDep (UnexpandedIvyDep org name rev cross) = match cross
  Constant = Some (IvyDep org name rev)
  _        = None

global def scalaCompilerIvyDep version =
  IvyDep "org.scala-lang" "scala-compiler" version.scalaVersionToString
global def scalaLibraryIvyDep version =
  IvyDep "org.scala-lang" "scala-library" version.scalaVersionToString

tuple ScalaModule =
  global Name:               String
  global RootDir:            String
  global ScalaVersion:       ScalaVersion
  global IvyDeps:            List UnexpandedIvyDep
  global Deps:               List ScalaModule
  # These are relative to RootDir
  global SourceDirs:         List String
  global ResourceDirs:       List String
  # These operations could be expensive
  global FnGeneratedSources: Unit => List Path
  global ScalacOptions:      List String
  global CompilerPlugins:    List UnexpandedIvyDep
  # We propagate errors
  global Error:              Option Error

def addSBTDefaults module =
  def sourceDirs = "src/main/scala", "src/main/java", _
  def resourceDirs = "src/main/resources", _
  module
  | editScalaModuleSourceDirs sourceDirs
  | editScalaModuleResourceDirs resourceDirs

global def scalaModuleToResult module =
  match module.getScalaModuleError
    None       = Pass module
    Some error = Fail error

global def makeScalaModule name dir version =
  ScalaModule name dir version Nil Nil Nil Nil (\_ Nil) Nil Nil None
  | addSBTDefaults

# TODO clean up
global def makeScalaModuleFromJSON dir name =
  def jsonProj =
    dir.readIvyDepsJSON
    | rmap (_ // name.quote)
  def scalaVersion =
    def helper json =
      json // `scalaVersion`
      | getJString
      | getOrFail (makeError "scalaVersion not found!")
      | rmapPass stringToScalaVersionResult
    jsonProj | rmapPass helper
  def ivyDeps =
    def helper json =
      json // `dependencies`
      | getJArray
      | getOrElse Nil
      | mapPartial getJString
      | map (\x stringToIvyDep x | getOrFail (makeError "Malformed IvyDep '{x}'"))
      | findFail
    jsonProj | rmapPass helper
  match scalaVersion ivyDeps
    (Pass ver) (Pass deps) = makeScalaModule name dir ver | setScalaModuleIvyDeps deps
    (Fail err) _           = makeBadScalaModule err
    _          (Fail err)  = makeBadScalaModule err

def makeBadScalaModule error =
  makeScalaModule "BAD_SCALA_MODULE" "/dev/null" (ScalaVersion 0 0)
  | setScalaModuleError (Some error)

def compareScalaModules a b =
  a.getScalaModuleName <=>* b.getScalaModuleName

target memoizeGenSrcs name \ module =
  module.getScalaModuleFnGeneratedSources Unit
global def getScalaModuleGeneratedSources module =
  memoizeGenSrcs module.getScalaModuleName module

# Given a directory, return all Java and Scala source files
def ourSources dir = sources dir `.*\.(scala|java)`

def getScalaModuleExpandedSourceDirs module =
  def mroot = module.getScalaModuleRootDir
  map (simplify "{mroot}/{_}") module.getScalaModuleSourceDirs

def getScalaModuleExpandedResourceDirs module =
  def mroot = module.getScalaModuleRootDir
  map (simplify "{mroot}/{_}") module.getScalaModuleResourceDirs

# Source files found in the source directories
def getScalaModuleSourceFiles module =
  # TODO should this be memoized?
  module.getScalaModuleExpandedSourceDirs | mapFlat ourSources

# Source files including generated sources
def getScalaModuleAllSourceFiles module =
  module.getScalaModuleSourceFiles ++ module.getScalaModuleGeneratedSources

# All files found in the resource directories
def getScalaModuleResourceFiles module =
  module.getScalaModuleExpandedResourceDirs | mapFlat (sources _ `.*`)

global def getScalaModuleTransDeps module =
  def err Unit =
    makeBadScalaModule (makeError "ScalaModule '{module.getScalaModuleName}' depends on itself!"), Nil
  def folder tree mod =
    foldl helper tree mod.getScalaModuleDeps
  def helper tree mod = match (mod ∈ tree)
    True = tree
    False = folder (tinsert mod tree) mod
  def tree = folder (tnew compareScalaModules) module
  if module ∈ tree then err Unit
  else tree | treeToList

# Excludes Scala itself
# Does not run expand ivy dependencies, nor does it invoke coursier
# TODO Make helper that takes an accumulator tree and checks if already present, returns if so, otherwise continues
global def getScalaModuleTransIvyDeps module =
  def allMods = module, module.getScalaModuleTransDeps
  def cmp = _.unexpandedIvyDepToString <=>* _.unexpandedIvyDepToString
  allMods | mapFlat getScalaModuleIvyDeps | distinctBy cmp

# TODO
#  - Calculate the relative path from build.sc to workspace root instead of ../../../..
global def genMillBuild module =
  def name = module.getScalaModuleName
  def scalaVersion = module.getScalaModuleScalaVersion
  def pathsToPrettyString paths =
    paths
    | map getPathName
    | map ("    \"{_}\"")
    | catWith ",\n"
  def srcs = module.getScalaModuleAllSourceFiles | pathsToPrettyString
  def resources = module.getScalaModuleResourceFiles | pathsToPrettyString
  def deps =
    def ivyDepsJars =
      module.getScalaModuleTransIvyDeps
      | map (expandIvyDep scalaVersion)
      | resolveIvyDeps
    def depJars =
      module.getScalaModuleTransDeps
      | map compileScalaModule
    depJars ++ ivyDepsJars
    | pathsToPrettyString
  "%
    // DO NOT MODIFY
    // This file is autogenerated by api-scala-sifive
    import mill._, scalalib._, os._
    object %{name} extends ScalaModule {
      def scalaVersion = "%{scalaVersion.scalaVersionToString}"
      def sourceFiles = Seq(
    %{srcs}
      )
      def depJars = Seq(
    %{deps}
      )
      def resourceFiles = Seq(
    %{resources}
      )
      def sources = T.sources {
        sourceFiles.map(f => PathRef(millSourcePath / RelPath(s"../../../../$f")))
      }
      def unmanagedClasspath = T {
        depJars.map(f => PathRef(millSourcePath / RelPath(s"../../../../$f")))
      }
      def resources = T.sources {
        resourceFiles.map(f => PathRef(millSourcePath / RelPath(s"../../../../$f")))
      }
    }
    %"

# TODO should we add Scala version to path?
#    We might be able to get mill to do this
def millBuildDir module =
  "{root.getPathName}/{module.getScalaModuleName}"

target millBuildFile name \ module =
  def text = genMillBuild module
  def filename = "{millBuildDir module}/build.sc"
  write filename text

global def mb module = millBuildFile module.getScalaModuleName module

# Compiles a ScalaModule returns generated jar
target memoizeMillCompile name \ module =
  # Build dir within which we run the mill process
  def buildDir = millBuildDir module
  def outDir = "{buildDir}/out"
  def jarName = "{outDir}/{name}/jar/dest/out.jar"
  # Relative paths for running the job in buildDIr
  def relMillBin = relative buildDir millBin.getPathName
  def relMillHome = relative buildDir millHome
  def relIvyCache = relative buildDir ivyCache

  def transDeps = module.getScalaModuleTransDeps
  def buildFile = millBuildFile name module
  def inputs =
    def sourceFiles = module.getScalaModuleAllSourceFiles ++ module.getScalaModuleResourceFiles
    def depJars = map compileScalaModule transDeps
    millBin, buildFile, depJars ++ sourceFiles ++ ivyCacheDeps
    | sortBy (_.getPathName <* _.getPathName) # Sorted to ensure hash is stable
  # This is a hack to ensure that changes to visible files rerun the job
  # We give directories as inputs to Bloop which then looks in those directories so new files m
  def visibleHashHack =
    def hash = (\x prim "hash") inputs
    "VISIBLE_FILES_HASH_HACK={format hash}"
  def cmd =
    "bash", relMillBin, "--no-default-predef", "--home", relMillHome, "show", "{name}.jar", Nil
  def plan =
    makePlan cmd inputs
    | editPlanEnvironment ("COURSIER_CACHE={relIvyCache}", visibleHashHack, _)
    | setPlanDirectory buildDir
    # Mill uses the entire classpath for caching so it must be local only for incremental compile
    | setPlanLocalOnly True
    | setPlanFnOutputs (\_ jarName, Nil)
    | setPlanResources resources
  plan
  | runJob
  | getJobOutput

global def compileScalaModule module = memoizeMillCompile module.getScalaModuleName module

# Returns the full classpath to run the module
global def scalaModuleClasspath module =
  def version = module.getScalaModuleScalaVersion
  def scalaIvyDep = scalaCompilerIvyDep version
  def ivyJars =
    def ivyDeps = module.getScalaModuleTransIvyDeps | map (expandIvyDep version)
    resolveIvyDeps (scalaIvyDep, ivyDeps)
  def moduleJars = (module, module.getScalaModuleTransDeps) | map compileScalaModule
  moduleJars ++ ivyJars
