
# Important directories
def buildRoot = mkdir "build"
def root = mkdir "{buildRoot.getPathName}/{here}"
def scalaInstall = "scala"
# Where I expect Scala Ivy dependencies to be downloaded
def ivyCache = "ivycache"
def resources = "python/python/3.7.1", "openjdk/java/1.8.0", Nil

global def readIvyDepsJSON dir =
  source "{dir}/ivydependencies.json" | parseJSONFile

# Use this to manually fetch scala dependencies, wake -x 'fetchScala Unit'
global def fetchScala Unit =
  match (ivyCacheDeps Unit | map getPathResult | findFail)
    Pass _paths = Pass "ivyCacheDeps"
    Fail err    = Fail err

publish preinstall = fetchScala, Nil

target fetchCoursier Unit =
  def bin = source "{here}/fetch_coursier"
  def dir = mkdir scalaInstall
  def deps = sources here `.*\.py`
  makePlan (bin.getPathName, dir.getPathName, Nil) (bin, dir, deps)
  | setPlanResources resources
  | editPlanEnvironment ("PYTHONDONTWRITEBYTECODE=1", _)
  | runJob
  | getJobOutput

# Get ivydependencies.json files 0 or 1 levels under workspace root, or that
# are explicitly published.
# 0/1 levels emulates Wit <= 0.12 behavior where packages are placed directly below
# the workspace root where Wit fetches dependencies in ivydependencies.json
# located at the root of packages.
global topic ivyDepLocations: String
def ivyDepsFiles =
  def addSuffix suffix str = "{str}{suffix}"
  def published = subscribe ivyDepLocations | map (addSuffix "/ivydependencies.json") | map source
  def traversed = sources "." `[^/]*/?ivydependencies\.json`
  def pathCmp a b = scmp a.getPathName b.getPathName
  traversed ++ published | distinctBy pathCmp

# Job that fetches ivy dependencies
target ivyCacheDeps Unit =
  def coursierBin = fetchCoursier Unit
  def bin = source "{here}/fetch_ivy_dependencies"
  def dir = mkdir scalaInstall
  def cache = mkdir ivyCache
  def otherDeps = sources here `.*\.py`
  def cmd =
    "python3", bin.getPathName, "--scala-dir", dir.getPathName, "--cache-dir",
    cache.getPathName, map getPathName ivyDepsFiles
  def allDeps = bin, dir, cache, coursierBin, otherDeps ++ ivyDepsFiles
  def listIvycache Unit = files ivyCache `.*`
  match ivyDepsFiles
    Nil = Nil
    _   =
      makePlan cmd allDeps
      | setPlanResources resources
      | editPlanEnvironment ("PYTHONDONTWRITEBYTECODE=1", _)
      | setPlanLocalOnly True
      # Own all files in ivycache, even if they were prefetched by Wit
      | setPlanFnOutputs (\_ listIvycache Unit)
      | runJob
      | getJobOutputs


# Memoized tree for converting from Strings to Paths to jars in Coursier cache
target ivyCacheJars Unit =
  def isJar = matches `.*\.jar` _.getPathName
  ivyCacheDeps Unit
  | filter isJar
  | mapPartial (\p p.getPathName.stripIvyPathPrefix | omap (Pair _ p))
  | listToTree cmpIvyCachePair

# TODO This is kind of sketchy, are releases and maven2 sufficient?
def stripIvyPathPrefix name =
  extract `.*?/(?:releases|maven2)/(.*)` name | head

def ivyDepToCoursierCache (IvyDep org name rev) =
  def prefix = replace `\.` '/' org
  "{prefix}/{name}/{rev}/{name}-{rev}.jar"

def cmpIvyCachePair (Pair n1 _) (Pair n2 _) = n1 <=>* n2

def getIvyDepJars filenames =
  def dummyPath = root # A explicitly dummy path
  def pairs = map (Pair _ dummyPath) filenames
  def mtree = listToTree cmpIvyCachePair pairs
  (ivyCacheJars Unit) ∩ mtree | treeToList | map getPairSecond

# Get the Jar for an IvyDep
# Returns a Path
global def getIvyDepJar dep =
  def err Unit =
    makeBadPath (makeError "{dep.ivyDepToString} not found in downloaded ivy dependencies!")
  def ivyDeps = getIvyDepJars (dep.ivyDepToCoursierCache, Nil)
  match ivyDeps
    value, Nil = value
    Nil        = err Unit
    l          = panic "Found multiple jars for {dep.ivyDepToString}: {format l}"

# TODO
# - Can we make this a fuse job? For some reason coursier can't find visible inputs
# Determines transitive ivy dependencies
# Given List IvyDep, returns List Path
# Returns paths to dep jars and transitive dependencies
global target resolveIvyDeps deps =
  def coursierBin = fetchCoursier Unit
  def depStrs = map ivyDepToString deps
  def cachedDeps = ivyCacheDeps Unit
  def job =
    def cmd = coursierBin.getPathName, "fetch", "-q", "--cache", ivyCache, "-m", "offline", depStrs
    makePlan cmd (coursierBin, cachedDeps)
    | setPlanLocalOnly True
    | runJob
  def strs =
    job
    | getJobStdout
    | rmap (tokenize `\n` _ | filter (_ !=* ""))
  # Using the output of coursier, we get the actual paths and filter into requested and transitive
  def stripPrefix str = stripIvyPathPrefix str | getOrFail (makeError "Could not strip ivy path prefix of '{str}'!")
  def filenames = strs | rmapPass (findFailFn stripPrefix _)
  def err paths names =
    def fns = catWith ", " names
    def ps = paths | map format | catWith ", "
    makeBadPath (makeError "Something went wrong! Looking for {fns}, got wrong number of paths: {ps}"), Nil
  match filenames
    Fail err = makeBadPath err, Nil
    Pass fns =
      def jars = getIvyDepJars fns
      if jars.len != fns.len then err jars fns else jars


# TODO improve
global def runIvyDep dep = resolveIvyDeps (dep, Nil) | runJava

# TODO improve
# - Customize java installation
# - Add Java options (eg. -Xmx4G)
# visible excludes classpath
global def runJava classpath main args visible =
  def cp = map getPathName classpath | catWith ":"
  def cmd = "java", "-cp", cp, main, args
  makePlan cmd (visible ++ classpath)
  | setPlanResources ("openjdk/java/1.8.0", Nil)
  | runJob

# TODO Dotty support?
tuple ScalaVersion =
  global Major: Integer
  global Minor: Integer

global def makeScalaVersion major minor =
  ScalaVersion major minor

global def scalaVersionToString (ScalaVersion major minor) =
  "2.{str major}.{str minor}"

global def scalaVersionMajorString (ScalaVersion major _) =
  "2.{str major}"


global def stringToScalaVersion str =
  match (tokenize `\.` str)
    "2", major, minor, Nil = match (int major) (int minor)
      (Some maj) (Some min) = Some (ScalaVersion maj min)
      _ _                   = None
    _ = None

global def stringToScalaVersionResult str =
  match (stringToScalaVersion str)
    Some ver = Pass ver
    None     = Fail (makeError "Invalid ScalaVersion string {str}")

global data ScalaCrossVersion =
  Constant
  Major
  Minor

# TODO additional resolvers/repositories
tuple IvyDep =
  global Org:          String
  global Name:         String
  global Rev:          String

tuple UnexpandedIvyDep =
  global Org:          String
  global Name:         String
  global Rev:          String
  global CrossVersion: ScalaCrossVersion

# rename stringToIvyDep
global def stringToIvyDep string =
  match (tokenize `:` string)
    org, name, rev, Nil         = Some (UnexpandedIvyDep org name rev Constant)
    org, "", name, rev, Nil     = Some (UnexpandedIvyDep org name rev Major)
    org, "", "", name, rev, Nil = Some (UnexpandedIvyDep org name rev Minor)
    _                           = None

def ivyDepToString (IvyDep org name rev) = "{org}:{name}:{rev}"

def unexpandedIvyDepToString (UnexpandedIvyDep org name rev cross) = match cross
  Constant = "{org}:{name}:{rev}"
  Major    = "{org}::{name}:{rev}"
  Minor    = "{org}:::{name}:{rev}"

global def expandIvyDep version (UnexpandedIvyDep org name rev cross) = match cross
  Constant = IvyDep org name rev
  Major    = IvyDep org "{name}_{scalaVersionMajorString version}" rev
  Minor    = IvyDep org "{name}_{scalaVersionToString version}" rev

global def expandJavaIvyDep (UnexpandedIvyDep org name rev cross) = match cross
  Constant = Some (IvyDep org name rev)
  _        = None

global def scalaCompilerIvyDep version =
  IvyDep "org.scala-lang" "scala-compiler" version.scalaVersionToString
global def scalaLibraryIvyDep version =
  IvyDep "org.scala-lang" "scala-library" version.scalaVersionToString

tuple ScalaModule =
  global Name:               String
  global RootDir:            String
  global ScalaVersion:       ScalaVersion
  global IvyDeps:            List UnexpandedIvyDep
  global Deps:               List ScalaModule
  # These are relative to RootDir
  global SourceDirs:         List String
  global ResourceDirs:       List String
  # These operations could be expensive
  global FnGeneratedSources: Unit => List Path
  global ScalacOptions:      List String
  global CompilerPlugins:    List UnexpandedIvyDep
  # We propagate errors
  global Error:              Option Error

def addSBTDefaults module =
  def sourceDirs = "src/main/scala", "src/main/java", _
  def resourceDirs = "src/main/resources", _
  module
  | editScalaModuleSourceDirs sourceDirs
  | editScalaModuleResourceDirs resourceDirs

global def scalaModuleToResult module =
  match module.getScalaModuleError
    None       = Pass module
    Some error = Fail error

global def makeScalaModule name dir version =
  ScalaModule name dir version Nil Nil Nil Nil (\_ Nil) Nil Nil None
  | addSBTDefaults

# TODO clean up
global def makeScalaModuleFromJSON dir name =
  def jsonProj =
    dir.readIvyDepsJSON
    | rmap (_ // name.quote)
  def scalaVersion =
    def helper json =
      json // `scalaVersion`
      | getJString
      | getOrFail (makeError "scalaVersion not found!")
      | rmapPass stringToScalaVersionResult
    jsonProj | rmapPass helper
  def ivyDeps =
    def helper json =
      json // `dependencies`
      | getJArray
      | getOrElse Nil
      | mapPartial getJString
      | map (\x stringToIvyDep x | getOrFail (makeError "Malformed IvyDep '{x}'"))
      | findFail
    jsonProj | rmapPass helper
  match scalaVersion ivyDeps
    (Pass ver) (Pass deps) = makeScalaModule name dir ver | setScalaModuleIvyDeps deps
    (Fail err) _           = makeBadScalaModule err
    _          (Fail err)  = makeBadScalaModule err

def makeBadScalaModule error =
  makeScalaModule "BAD_SCALA_MODULE" "/dev/null" (ScalaVersion 0 0)
  | setScalaModuleError (Some error)

def compareScalaModules a b =
  a.getScalaModuleName <=>* b.getScalaModuleName

target memoizeGenSrcs name \ module =
  module.getScalaModuleFnGeneratedSources Unit
global def getScalaModuleGeneratedSources module =
  memoizeGenSrcs module.getScalaModuleName module

# Given a directory, return all Java and Scala source files
def ourSources dir = sources dir `.*\.(scala|java)`

def getScalaModuleExpandedSourceDirs module =
  def mroot = module.getScalaModuleRootDir
  map (simplify "{mroot}/{_}") module.getScalaModuleSourceDirs

def getScalaModuleExpandedResourceDirs module =
  def mroot = module.getScalaModuleRootDir
  map (simplify "{mroot}/{_}") module.getScalaModuleResourceDirs

# Source files found in the source directories
def getScalaModuleSourceFiles module =
  # TODO should this be memoized?
  module.getScalaModuleExpandedSourceDirs | mapFlat ourSources

# Source files including generated sources
def getScalaModuleAllSourceFiles module =
  module.getScalaModuleSourceFiles ++ module.getScalaModuleGeneratedSources

# All files found in the resource directories
def getScalaModuleResourceFiles module =
  module.getScalaModuleExpandedResourceDirs | mapFlat (sources _ `.*`)

global def getScalaModuleTransDeps module =
  def err Unit =
    makeBadScalaModule (makeError "ScalaModule '{module.getScalaModuleName}' depends on itself!"), Nil
  def folder tree mod =
    foldl helper tree mod.getScalaModuleDeps
  def helper tree mod = match (mod ∈ tree)
    True = tree
    False = folder (tinsert mod tree) mod
  def tree = folder (tnew compareScalaModules) module
  if module ∈ tree then err Unit
  else tree | treeToList

# Excludes Scala itself
# Does not run expand ivy dependencies, nor does it invoke coursier
# TODO Make helper that takes an accumulator tree and checks if already present, returns if so, otherwise continues
global def getScalaModuleTransIvyDeps module =
  def allMods = module, module.getScalaModuleTransDeps
  def cmp = _.unexpandedIvyDepToString <=>* _.unexpandedIvyDepToString
  allMods | mapFlat getScalaModuleIvyDeps | distinctBy cmp

# Important output directories
def buildDir module =
  def suffix = module.getScalaModuleScalaVersion.scalaVersionMajorString
  mkdir "{buildRoot.getPathName}/{module.getScalaModuleName}/scala-{suffix}"
def moduleClassesDir module = mkdir "{module.buildDir.getPathName}/classes"
def moduleOutputJar module = "{module.buildDir.getPathName}/out.jar"

# Utilities for dealing with Pairs
def pcat pairsOfLists =
  def helper (Pair l1 r1) (Pair l2 r2) = Pair (l1 ++ l2) (r1 ++ r2)
  foldl helper (Pair Nil Nil) pairsOfLists

def pmapl f (Pair l r) = Pair (f l) r
def pmapr f (Pair l r) = Pair l (f r)

def filesPair fs = Pair (fs | map getPathName) fs

def scalac scalaVersion =
  def coursierBin = fetchCoursier Unit
  def ivyDep = scalaCompilerIvyDep scalaVersion | ivyDepToString
  def l = coursierBin.getPathName, "launch", "--cache", ivyCache, "-m", "offline", ivyDep, "-M", "scala.tools.nsc.Main", Nil
  def r = coursierBin, ivyCacheDeps Unit
  Pair l r

# Get all compile dependencies as jars
# Return type: Pair (List String) (List Path)
def scalaModuleCompileClasspath module =
  def scalaVersion = module.getScalaModuleScalaVersion
  def ivyJars =
    def ivyDeps = module.getScalaModuleTransIvyDeps
    def deps = ivyDeps | map (expandIvyDep scalaVersion _)
    def scalaLibDep = scalaVersion.scalaLibraryIvyDep
    (scalaLibDep, deps)
    | resolveIvyDeps
  def moduleJars =
    module.getScalaModuleTransDeps
    | map compileScalaModule
  moduleJars ++ ivyJars
  | filesPair

# Get plugins as arguments to Scalac
# Return type: Pair (List String) (List Path)
def compilerPluginsAsArgs module =
  def scalaVersion = module.getScalaModuleScalaVersion
  module.getScalaModuleCompilerPlugins
  | map (expandIvyDep scalaVersion)
  | map getIvyDepJar
  | filesPair
  | pmapl (map ("-Xplugin:{_}"))

# Get all arguments to compile the module with Scalac
# Also return List of all files that need to be read for compilation
# Return type: Pair (List String) (List Path)
def scalacArgs module =
  def classpath =
    scalaModuleCompileClasspath module
    | pmapl (catWith ":")
    | pmapl ("-classpath {_}", Nil)
  def destDir =
     def dir = module.moduleClassesDir
     Pair ("-d {dir.getPathName}", Nil) (dir, Nil)
  def scalacOpts = Pair module.getScalaModuleScalacOptions Nil
  def pluginArgs = compilerPluginsAsArgs module
  def sourceFiles = module.getScalaModuleAllSourceFiles | filesPair
  pcat (classpath, destDir,  scalacOpts, pluginArgs, sourceFiles, Nil)

# Write all arguments to Scalac to compile this module to a file
def scalacArgsFile module =
  def filename = "{module.buildDir.getPathName}/scalac_args"
  match (scalacArgs module)
    Pair lines files =
      def content = catWith "\n" lines
      def written = write filename content
      Pair written (written, files)

def scalacCompile module =
  def Pair baseCmd vfiles1 = scalac module.getScalaModuleScalaVersion
  def Pair argFile vfiles2 = scalacArgsFile module
  def cmd = baseCmd ++ ("--", "@{argFile.getPathName}", Nil)
  makePlan cmd (vfiles1 ++ vfiles2)
  | setPlanResources resources
  | runJob

def compileAndJar module =
  def compiledArtifacts = scalacCompile module | getJobOutputs
  def allDirs = module.moduleClassesDir.getPathName, module.getScalaModuleExpandedResourceDirs
  def resourceFiles = module.getScalaModuleResourceFiles
  def bin = source "{here}/make_jar"
  def pyDeps = sources here `.*\.py`
  def cmd = "python3", bin.getPathName, module.moduleOutputJar, allDirs
  def inputs = bin, pyDeps ++ compiledArtifacts ++ resourceFiles
  makePlan cmd inputs
  | editPlanEnvironment ("PYTHONDONTWRITEBYTECODE=1", _)
  | setPlanResources resources
  | runJob

global def compileScalaModule module =
  match module.scalaModuleToResult
    Pass _   = module.compileAndJar | getJobOutput
    Fail err = makeBadPath err

# Returns the full classpath to run the module
global def scalaModuleClasspath module =
  def version = module.getScalaModuleScalaVersion
  def scalaIvyDep = scalaCompilerIvyDep version
  def ivyJars =
    def ivyDeps = module.getScalaModuleTransIvyDeps | map (expandIvyDep version)
    resolveIvyDeps (scalaIvyDep, ivyDeps)
  def moduleJars = (module, module.getScalaModuleTransDeps) | map compileScalaModule
  moduleJars ++ ivyJars
